import { NextResponse } from 'next/server';
import { prisma } from '@/lib/db';
import { verifyAccessToken } from '@/lib/auth';
import { leaseListingIntegration } from '@/lib/lease-listing-integration';
import { cookies } from 'next/headers';

export async function POST(
  request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    // 1. Authentication
    const cookieStore = await cookies();
    const token = cookieStore.get('token')?.value;
    if (!token) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    let payload;
    try {
      payload = verifyAccessToken(token);
    } catch (authError) {
      console.error('Auth Token Verification Error:', authError);
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    if (!payload?.organizationId) {
      return NextResponse.json({ error: 'Organization required' }, { status: 403 });
    }

    const orgId = payload.organizationId;
    const { id: leaseId } = await params;

    // 2. Get the lease with validation
    const lease = await prisma.lease.findFirst({
      where: {
        id: leaseId,
        property: {
          organizationId: orgId
        }
      },
      include: {
        unit: true,
        property: true
      }
    });

    if (!lease) {
      return NextResponse.json(
        { error: 'Lease not found or unauthorized' },
        { status: 404 }
      );
    }

    // 3. Validate lease status
    if (!['DRAFT', 'SIGNED'].includes(lease.leaseStatus || '')) {
      return NextResponse.json(
        { error: 'Lease cannot be activated. Current status: ' + lease.leaseStatus },
        { status: 400 }
      );
    }

    const previousStatus = lease.leaseStatus;

    // 4. Update lease status to ACTIVE
    const updatedLease = await prisma.lease.update({
      where: { id: leaseId },
      data: {
        leaseStatus: 'ACTIVE',
        landlordSignedAt: new Date()
      }
    });

    // 5. Mark unit as occupied
    await prisma.unit.update({
      where: { id: lease.unitId },
      data: { isOccupied: true }
    });

    // 6. Handle listing integration after successful database update
    try {
      await leaseListingIntegration.handleLeaseStatusChange(
        leaseId,
        'ACTIVE',
        previousStatus,
        payload.userId
      );
    } catch (integrationError) {
      console.error('Lease-listing integration error:', integrationError);
      // Don't fail the request if integration fails, but log it
      // The lease activation was successful, integration can be retried
    }

    // 7. Generate first invoice if start date is current or past
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const startDate = new Date(lease.startDate);
    startDate.setHours(0, 0, 0, 0);

    let invoiceCreated = false;
    if (startDate <= today) {
      // Create first rent invoice
      const invoice = await prisma.invoice.create({
        data: {
          leaseId: leaseId,
          type: 'RENT',
          totalAmount: lease.rentAmount,
          amountPaid: 0,
          balance: lease.rentAmount,
          dueDate: new Date(lease.startDate),
          status: 'PENDING',
          postingStatus: 'PENDING'
        }
      });
      invoiceCreated = true;

      // TODO: Generate journal entry for the invoice
      // This would typically call a finance service to create the journal entry
    }

    return NextResponse.json({
      success: true,
      message: 'Lease activated successfully',
      leaseId: updatedLease.id,
      leaseStatus: updatedLease.leaseStatus,
      invoiceCreated,
      note: invoiceCreated
        ? 'First invoice generated'
        : 'Start date is in the future - invoice will be generated by cron on start date'
    });

  } catch (error: unknown) {
    console.error('Lease activation error:', error);
    const errorMessage = error instanceof Error ? error.message : 'Internal Server Error';
    return NextResponse.json(
      { error: errorMessage },
      { status: 500 }
    );
  }
}